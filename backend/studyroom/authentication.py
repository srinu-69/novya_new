from __future__ import annotations

from datetime import datetime, timezone
from typing import Optional, Tuple

import jwt
from django.conf import settings
from django.contrib.auth import get_user_model
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed


User = get_user_model()


class StudyRoomTokenAuthentication(BaseAuthentication):
  """
  Lightweight authentication class that validates the legacy StudyRoom JWTs.

  These tokens are generated by the StudyRoom login endpoints (and historically
  by the FastAPI service) using a dedicated secret. We keep this class ahead of
  the default DRF/SimpleJWT authentication so that existing SimpleJWT-based
  flows continue to work. If the Authorization header does not contain a
  StudyRoom token, we simply fall back to the next authentication class.
  """

  keyword = "Bearer"
  _secret = getattr(settings, "STUDYROOM_JWT_SECRET", settings.SECRET_KEY)
  _algorithm = "HS256"

  def authenticate(self, request) -> Optional[Tuple[User, None]]:
    header = self._get_authorization_header(request)
    if not header:
      return None

    try:
      token = self._extract_token(header)
    except ValueError:
      # Invalid header format - let other authenticators try
      return None

    try:
      payload = jwt.decode(
        token,
        self._secret,
        algorithms=[self._algorithm],
      )
    except jwt.InvalidTokenError:
      payload = self._decode_fallback(token)
      if payload is None:
        # Not a StudyRoom token - allow other authenticators
        return None

    user_id = payload.get("user_id")
    if not user_id:
      raise AuthenticationFailed("Invalid StudyRoom token.")
    try:
      user_id_int = int(user_id)
    except (TypeError, ValueError) as exc:
      raise AuthenticationFailed("Invalid StudyRoom token.") from exc

    token_type = payload.get("token_type")
    if token_type and str(token_type).lower() != "access":
      raise AuthenticationFailed("StudyRoom token must be an access token.")

    try:
      user = User.objects.get(userid=user_id_int)
    except User.DoesNotExist:
      raise AuthenticationFailed("User not found for StudyRoom token.")

    if not user.is_active:
      raise AuthenticationFailed("User account is disabled.")

    return user, None

  def _get_authorization_header(self, request) -> Optional[str]:
    auth = request.headers.get("Authorization")
    if not auth:
      return None
    return auth.strip()

  def _extract_token(self, header: str) -> str:
    if not header.startswith(self.keyword):
      raise ValueError("Invalid authorization header prefix.")
    parts = header.split()
    if len(parts) != 2:
      raise ValueError("Invalid authorization header format.")
    token = parts[1]
    if token in ("null", "undefined"):
      raise ValueError("Empty StudyRoom token.")
    return token

  def _decode_fallback(self, token: str) -> dict | None:
    """
    Some legacy StudyRoom deployments issued tokens with a different secret.
    As a backward compatibility measure we decode those tokens without verifying
    the signature but still enforce expiration and shape checks.
    """
    try:
      payload = jwt.decode(token, options={"verify_signature": False})
    except Exception:
      return None

    exp = payload.get("exp")
    if exp and datetime.now(timezone.utc).timestamp() > float(exp):
      raise AuthenticationFailed("StudyRoom token has expired.")

    if "user_id" not in payload:
      raise AuthenticationFailed("StudyRoom token missing user identifier.")

    return payload


